package actions

import (
	"fmt"
	"time"

	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/pop"
	"github.com/gobuffalo/uuid"
	"github.com/nicomo/kumano/mailers"
	"github.com/nicomo/kumano/models"
	"github.com/pkg/errors"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (User)
// DB Table: Plural (users)
// Resource: Plural (Users)
// Path: Plural (/users)
// View Template Folder: Plural (/templates/users/)

// UsersResource is the resource for the User model
type UsersResource struct {
	buffalo.Resource
}

// List gets all Users. This function is mapped to the path
// GET /users
func (v UsersResource) List(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	users := &models.Users{}

	// Paginate results. Params "page" and "per_page" control pagination.
	// Default values are "page=1" and "per_page=20".
	q := tx.PaginateFromParams(c.Params())

	// Retrieve all Users from the DB
	if err := q.All(users); err != nil {
		return errors.WithStack(err)
	}

	// Add the paginator to the context so it can be used in the template.
	c.Set("pagination", q.Paginator)

	return c.Render(200, r.Auto(c, users))
}

// Show gets the data for one User. This function is mapped to
// the path GET /users/{user_id}
func (v UsersResource) Show(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Allocate an empty User
	user := &models.User{}

	// To find the User the parameter user_id is used.
	if err := tx.Find(user, c.Param("user_id")); err != nil {
		return c.Error(404, err)
	}

	// Is the user looking at own profile?
	if c.Session().Get("current_user_id") != nil {
		c.Set("self", c.Session().Get("current_user_id").(uuid.UUID).String() == c.Param("user_id"))
	} else {
		c.Set("self", false)
	}

	return c.Render(200, r.Auto(c, user))
}

// New renders the form for creating a new User.
// This function is mapped to the path GET /users/new
func (v UsersResource) New(c buffalo.Context) error {
	return c.Render(200, r.Auto(c, &models.User{}))
}

// Create adds a User to the DB. This function is mapped to the
// path POST /users
func (v UsersResource) Create(c buffalo.Context) error {

	// redirect url
	redirectURL := "users/" + c.Session().Get("current_user_id").(uuid.UUID).String()

	// Allocate an empty User
	user := &models.User{}

	// Bind user to the html form elements
	if err := c.Bind(user); err != nil {
		return errors.WithStack(err)
	}

	// add invitation token and time + sponsor ID
	invitationToken, err := uuid.NewV4()
	if err != nil {
		fmt.Printf("Couldn't create uuid for invitation token: %s", err)
		return c.Redirect(422, redirectURL)
	}
	user.InvitationToken = invitationToken.String()
	user.InvitedAt = time.Now()
	user.SponsorID = c.Session().Get("current_user_id").(uuid.UUID)

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Validate the data from the html form
	// FIXME: check unique email
	verrs, err := tx.ValidateAndCreate(user, "provider", "provider_id")
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Make the errors available inside the html template
		c.Set("errors", verrs)
		fmt.Printf("\nverrs: %v\n", verrs)
		// Redirect to sponsor profile
		return c.Redirect(302, redirectURL)
	}

	// send email to invited user
	sponsor := c.Value("current_user").(*models.User)

	emailData := map[string]string{
		"emailTo":         user.Email.String,
		"invitationURL":   "http://127.0.0.1:3000/auth/invitation/" + user.InvitationToken,
		"sponsorName":     sponsor.Name.String,
		"sponsorNickname": sponsor.Nickname.String,
		"sponsorID":       user.SponsorID.String(),
	}

	if err := mailers.SendInvitation(emailData); err != nil {
		fmt.Print(err)
		c.Flash().Add("danger", T.Translate(c, "users.sendinvitation.failure"))
	} else {
		// If there are no errors set a success message
		c.Flash().Add("success", T.Translate(c, "users.sendinvitation.success"))
	}

	// and redirect to the users index page
	return c.Redirect(302, redirectURL)
}

// Edit renders a edit form for a User. This function is
// mapped to the path GET /users/{user_id}/edit
func (v UsersResource) Edit(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Allocate an empty User
	user := &models.User{}

	if err := tx.Find(user, c.Param("user_id")); err != nil {
		return c.Error(404, err)
	}

	return c.Render(200, r.Auto(c, user))
}

// Update changes a User in the DB. This function is mapped to
// the path PUT /users/{user_id}
func (v UsersResource) Update(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Allocate an empty User
	user := &models.User{}

	if err := tx.Find(user, c.Param("user_id")); err != nil {
		return c.Error(404, err)
	}

	// Bind User to the html form elements
	if err := c.Bind(user); err != nil {
		return errors.WithStack(err)
	}

	verrs, err := tx.ValidateAndUpdate(user)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Make the errors available inside the html template
		c.Set("errors", verrs)

		// Render again the edit.html template that the user can
		// correct the input.
		return c.Render(422, r.Auto(c, user))
	}

	// If there are no errors set a success message
	c.Flash().Add("success", T.Translate(c, "user.updated.success"))

	// and redirect to the users index page
	return c.Render(200, r.Auto(c, user))
}

// Destroy deletes a User from the DB. This function is mapped
// to the path DELETE /users/{user_id}
func (v UsersResource) Destroy(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Allocate an empty User
	user := &models.User{}

	// To find the User the parameter user_id is used.
	if err := tx.Find(user, c.Param("user_id")); err != nil {
		return c.Error(404, err)
	}

	if err := tx.Destroy(user); err != nil {
		return errors.WithStack(err)
	}

	// If there are no errors set a flash message
	c.Flash().Add("success", T.Translate(c, "user.destroyed.success"))

	// Redirect to the users index page
	return c.Render(200, r.Auto(c, user))
}

// SetCurrentUser is a middleware that sets the user in the session
func SetCurrentUser(next buffalo.Handler) buffalo.Handler {
	return func(c buffalo.Context) error {
		if uid := c.Session().Get("current_user_id"); uid != nil {
			u := &models.User{}
			tx := c.Value("tx").(*pop.Connection)
			if err := tx.Find(u, uid); err != nil {
				return errors.WithStack(err)
			}
			c.Set("current_user", u)
		}
		return next(c)
	}
}

// AdminRequired middleware checks the user is logged in + an admin before accessing route.
func AdminRequired(next buffalo.Handler) buffalo.Handler {
	return func(c buffalo.Context) error {
		u, ok := c.Value("current_user").(*models.User)
		if ok && !u.IsAdmin {
			c.Flash().Add("danger", "Only admins get to view this page. You're missing out, I'll tell you.")
			return c.Redirect(302, "/")
		}
		return next(c)
	}
}

// LoginRequired middleware checks the user is logged in before accessing route.
func LoginRequired(next buffalo.Handler) buffalo.Handler {
	return func(c buffalo.Context) error {
		_, ok := c.Value("current_user").(*models.User)
		if ok {
			return next(c)
		}
		c.Flash().Add("danger", T.Translate(c, "users.loginrequired"))
		return c.Redirect(302, "/")
	}
}

// CanPost checks if user has already posted in last 24 hours
/*
func CanPost(user *models.User, next buffalo.Context) buffalo.Context {
	// id est : 1 post per 24 hours max.
	diff := time.Since(user.LastPostedAt)
	if diff.Hours() < 24.0 {
		next.Set("user_can_post", false)
		next.Flash().Add("info", fmt.Sprintf("Slow down (last post was %s ago). You can still work on drafts though.", diff.Truncate(time.Second).String()))
	} else {
		next.Set("user_can_post", true)
	}
	return next
}
*/
